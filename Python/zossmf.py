from datetime import datetime


#######################################################
# 単位の変換で使用する定数を定義                      #
#######################################################

DAY_IN_SEC         = 24*60*60               # 1日 ＝ 24時間 = 24 x 60分 = 24 x 60 x 60 秒　= 86400 秒

HOUR_IN_MIN        = 60                     # 1時間 = 60分
HOUR_IN_SEC        = 60*60                  # 1時間 = 60分 = 60 x 60 秒 = 3600 秒
HOUR_IN_100THS_SEC = 60*60*100              # 1時間 = 60分 = 60 x 60 秒 = 60 x 60 x 100 [1/100秒] = 360000 [1/100秒]

MIN_IN_SEC         = 60                     # 1分 = 60 秒
MIN_IN_100THS_SEC  = 60*100                 # 1分 = 60秒  = 60 x 100 [1/100秒] = 6000 [1/100秒]
MIN_IN_MILSEC      = 60 * 1000              # 1分 = 60秒  = 60 x 1000 ミリ秒 = 60000 ミリ秒

SEC_IN_100THS_SEC  = 100                    # 1秒 = 100  [1/100秒]
SEC_IN_MILSEC      = 1000                   # 1秒 = 1000 ミリ秒
SEC_IN_MICROSEC    = SEC_IN_MILSEC * 1000   # 1秒 = 1000 ミリ秒 = 1000 x 1000 μ秒 = 1000000 μ秒

MILSEC_IN_MICROSEC = 1000                   # 1ミリ秒 = 1000 μ秒

UNIT_128MICROSEC   = 128                    # 1unit = 128 μ秒
UNIT_1024MICROSEC  = 1024                   # 1unit = 1024 μ秒 = 1.024 ミリ秒

YEAR_IN_SEC_NORMAL = DAY_IN_SEC * 365       # 1年(うるう年以外) = 1日×365日 = 86400秒×365 = 31536000 秒
YEAR_IN_SEC_LEAP   = DAY_IN_SEC * 366       # 1年(うるう年) = 1日×366日 = 86400秒×366 = 31622400 秒

'''
1900年1月1日 00:00:00 から 1970年1月1日 00:00:00 までの秒数
間のうるう年は 1904、1908、…、1968 の17年のみ。
(1900年は100で割り切れ400で割り切れないので平年)
平年は 1970 - 1900 - 17 = 70 - 17 = 53年
'''
SEC_1900_1970 = YEAR_IN_SEC_NORMAL * 53 + YEAR_IN_SEC_LEAP * 17


#######################################################
# SMFの素データを分かりやすく変換するための関数を定義 #
#######################################################


def format_100ths_sec(inVal):
    '''
    00:00:00 からの時間（単位：1/100秒）を hh:mm:ss.tt の形式の文字列に変換する。
    
    パラメータ
    -----------
    inVal:  00:00:00 からの時間（単位：1/100秒）を想定
    
    戻り値
    -----------
    formattedTime :  hh:mm:ss.tt の形式の文字列
    '''
    
    hh = inVal // HOUR_IN_100THS_SEC
    mm = (inVal % HOUR_IN_100THS_SEC) // MIN_IN_100THS_SEC
    ss = (inVal % MIN_IN_100THS_SEC) // SEC_IN_100THS_SEC
    tt = inVal % SEC_IN_100THS_SEC
                                                             
    formattedTime = "%02d:%02d:%02d.%02d" % (hh, mm, ss, tt)
    
    return formattedTime


def format_0cyyddd(cyyddd):
    '''
    0cyydddF の形式の日付を yyyy-mm-dd の形式の文字列に変換する。
    
    パラメータ
    -----------
    cyyddd:  0cyydddF の形式の日付 (c:センチュリー・コード、yy:年の下二桁、ddd:ジュリアン・デート) を想定
    
    戻り値
    -----------
    yyyymmdd :  yyyy-mm-dd の形式の文字列
    '''
    
    # 0cyyddd が 0 で記録されているケースがあるため、その場合ははっきり例外と分かる日付を返す
    if cyyddd == 0 :
        return "0000-00-00"
    
    
    ddd = cyyddd % 1000    # ジュリアン・デートの取得
    cyy = cyyddd // 1000   # 年の取得
    yyyy = 1900 + cyy
    
    '''
    yyyy年の年初の日付をPOSIXタイムスタンプ('1970-01-01 00:00:00' UTC 以来の秒数)へと変換し
    そこにジュリアン・デート - 1日分の秒数を加算し、ジュリアン・デートに該当するUnixタイムスタンプを算出。
    その後、再び通常のタイムスタンプ形式 yyyy-mm-dd hh:mm:ss.tttttt に変換
    '''
    year_begin_date = datetime(yyyy, 1, 1).timestamp()
    yyyymmdd_hhmmss = datetime.fromtimestamp(year_begin_date + ((ddd - 1) * DAY_IN_SEC))
 
    # 最後に yyyy-mm-dd hh:mm:ss.tttttt から yyyy-mm-dd 部分だけを取得
    yyyymmdd = yyyymmdd_hhmmss.strftime('%Y-%m-%d')

    return yyyymmdd


def format_signedTOD(signedTod):
    ''' 
    TOD形式の日付、時刻を yyyy-mm-dd hh:mm:ss.tttuuu の形式の文字列に変換する。
    ただし、本来TODは符号なしであるがMDSで返される値は符号ありのLongになってしまっているため、それを考慮して変換する。
    
    パラメータ
    -----------
    signedTod: TOD形式(ビット51がマイクロ秒相当で1900年1月1日午前0時O分0秒からの時間を表した数値)を想定。
               ただし、64bitのLong型は符号ありのため、そのままアクセスすると負の数値となってしまう可能性がある。
               
    戻り値
    -----------
    formattedTimestamp :  yyyy-mm-dd hh:mm:ss.tttuuu形式の文字列
    '''
    
    # signedTod が 0 で記録されているケースがあるため、その場合ははっきり例外と分かるタイムスタンプを返す
    if signedTod == 0 :
        return "0000-00-00 00:00:00.000000"
    
    
    '''
    64ビットの場合、2進での表現は以下のようになっている。
    
      　　　　　　　          0000 0000 0011 1111 1111 2222 2222 2233 3333 3333 4444 4444 4455 5555 5555 6666
      符号ありの場合          0123 4567 8901 2345 6789 0123 4567 8901 2345 6789 0123 4567 8901 2345 6789 0123     符号なしの場合
     ---------------------- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----    -------------------
      9223372036854775807 = 0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111     符号ありと同じ
      9223372036854775806 = 0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1110     符号ありと同じ
      9223372036854775805 = 0111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1101     符号ありと同じ
                        :                                        :
                        2 = 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010     符号ありと同じ
                        1 = 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001     符号ありと同じ
                        0 = 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000     符号ありと同じ
         　　　　　　    -1 = 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111  => 18446744073709551615 (=2^64 - 1)
                       -2 = 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1110  => 18446744073709551614
                       -3 = 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1101  => 18446744073709551613
                       -4 = 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1111 1100  => 18446744073709551612
                        :                                        :                                                     :
     -9223372036854775806 = 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0010  =>   223372036854775810
     -9223372036854775807 = 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0001  =>   223372036854775809                                
     -9223372036854775808 = 1000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000  =>   223372036854775808  (=2^63)
     
     負の数の場合はその数に 2^64 = 18446744073709551616 を足せば、本来符号なしで表したかった数になる。
     他の言語だとこの数は符号付きLongでは表現出来ないが、Python3の場合、18446744073709551616 を足してもオーバーフローしないようなので、
     値が負の場合は 2^64 を足し算して、正しい値に戻す。
     その後、ビット操作の演算子で12ビット右にずらしてマイクロ秒を得るようにする。（ビット51より後ろは使用しない。Pythonの場合、ビットのシフト）
     '''
    unsignedTod = signedTod if signedTod > 0 else signedTod + 18446744073709551616
    microsec_from_1900 = unsignedTod >> 12
    
    '''
    datetimeモジュールのfromtimestamp関数を使うため、1900年からのマイクロ秒を1970年からの秒数に変換する。
    (POSIXタイムスタンプは '1970-01-01 00:00:00' UTC 以来の秒数)
    POSIXタイムスタンプでは秒未満の精度が消えてしまうため、秒未満の数値もとっておく。
    (後ほど yyyy-mm-dd hh:mm:ss.tttuuu の tttuuu 部分で使用する。)
    '''
    tttuuu = microsec_from_1900 % SEC_IN_MICROSEC
    sec_from_1900 = microsec_from_1900 // SEC_IN_MICROSEC
    sec_from_1970 = sec_from_1900 - SEC_1900_1970

    yyyymmdd_hhmmss = datetime.fromtimestamp(sec_from_1970)
    formattedTimestamp = "%s.%06d" %  (yyyymmdd_hhmmss, tttuuu)
    

    return formattedTimestamp


def signedInt_to_Long(signedInt):
    ''' 
    関数：signedInt_to_Long
        本来4バイトの符号なしIntegerとして扱われるべき数値が、MDSでは符号ありのIntegerとして値が返されるケースがある。
        この場合、本来は正の大きな値(0b 1xxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx)であるはずの数値が負の値となってしまう。
        そこで、本来は符号なしIntegerであるはずの入力のIntegerを、本来の正の値を持つ Long に変換する。
    パラメータ
    -----------
    signedInt: 本来は符号なしIntegerとして扱われるべき、符号付きのIntegerを想定。
    
    戻り値
    -----------
    unsignedLong :  入力の Integer を Long に変換した値を返す。ただし、入力が負の場合は、本来の正の値としての値を返す。
    '''

    '''
    32ビット(4バイト)の場合、2進での表現は以下のようになっている。
    
                       0000 0000 0011 1111 1111 2222 2222 2233
      符号ありの場合   0123 4567 8901 2345 6789 0123 4567 8901     符号なしの場合
     ----------------- ---- ---- ---- ---- ---- ---- ---- ----    -------------------
          2147483647 = 0111 1111 1111 1111 1111 1111 1111 1111     符号ありと同じ
          2147483646 = 0111 1111 1111 1111 1111 1111 1111 1110     符号ありと同じ
          2147483645 = 0111 1111 1111 1111 1111 1111 1111 1101     符号ありと同じ
                        :                                        :
                   2 = 0000 0000 0000 0000 0000 0000 0000 0010     符号ありと同じ
                   1 = 0000 0000 0000 0000 0000 0000 0000 0001     符号ありと同じ
                   0 = 0000 0000 0000 0000 0000 0000 0000 0000     符号ありと同じ
         　　 　   -1 = 1111 1111 1111 1111 1111 1111 1111 1111  =>   4294967295 (=2^32 - 1)
                  -2 = 1111 1111 1111 1111 1111 1111 1111 1110  =>   4294967294
                  -3 = 1111 1111 1111 1111 1111 1111 1111 1101  =>   4294967293
                  -4 = 1111 1111 1111 1111 1111 1111 1111 1100  =>   4294967292
                   :                  :                                     :
         -2147483646 = 1000 0000 0000 0000 0000 0000 0000 0010  =>   2147483650
         -2147483647 = 1000 0000 0000 0000 0000 0000 0000 0001  =>   2147483649
         -2147483648 = 1000 0000 0000 0000 0000 0000 0000 0000  =>   2147483648  (=2^31)
     
     負の数の場合はその数に 2^32 = 4294967296 を足せば、本来符号なしで表したかった数になる。
     '''
    
    unsignedLong = signedInt if signedInt >= 0 else signedInt + 4294967296
    
    return unsignedLong

#################################################################
# SMF 30 の主要な項目を Padnas のDataframe に変換する関数を定義 #
#################################################################

import pandas as pd
import dsdbc


sql_smf30 = ("select H.SMF_TIME,"
             "        H.SMF_SID,"
             "        H.SMF_SSI,"
             "        H.SMF_STY,"
             "        I.SMF30JBN,"
             "        I.SMF30PGM,"
             "        I.SMF30STM,"
             "        I.SMF30JNM,"
             "        I.SMF30STN,"
             "        I.SMF30SIT,"
             "        I.SMF30STD,"
             "        P.SMF30CPT,"
             "        P.SMF30CPS"
             "   from SMF_03000__%s as H,"
             "        SMF_03000_SMF30ID__%s as I,"
             "        SMF_03000_SMF30CAS__%s as P"
             "  where H.SMF_STY IN (4, 5)"
             "    and H.CHILD_KEY = I.PARENT_KEY"
             "    and H.CHILD_KEY = P.PARENT_KEY")


def smf30_to_pandas(ssid, smfdsn):
    # アクセスするデータセット名を付加した仮想表の名前を定義
    smf_dsn_ = smfdsn.replace(".","_")
    sql_smf30_ = sql_smf30 % (smf_dsn_ , smf_dsn_ , smf_dsn_ )
    
    conn = dsdbc.connect(SSID=ssid)
    df_smf30 = pd.read_sql(sql_smf30_, con=conn)    
    
    df_smf30_fmt = df_smf30.copy()
    
    # データの加工 : Identificationセクション
    
    # SMF30SIT : イニシエーターがこのJOBもしくはSTEPを選択した時間。00:00:00 からの時間（単位：1/100秒）
    df_smf30_fmt["SMF30SIT"] = df_smf30["SMF30SIT"].map(format_100ths_sec)

    # SMF30STD: イニシエーターがこのJOBもしくはSTEPを選択した日付。
    #           0cyydddF の形式 (c:センチュリー・コード、yy:年の下二桁、ddd:ジュリアン・デート)
    df_smf30_fmt["SMF30STD"] = df_smf30["SMF30STD"].map(format_0cyyddd)
    

    # データの加工 : Processor Accountingセクション
    
    # SMF30CPT : 通常CPで消費されたTCB時間、エンクレーブ時間、プリエンタブルSRB時間、
                 クライアントSRB時間の合計 (単位：1/100秒）
    df_smf30_fmt["SMF30CPT"] = df_smf30["SMF30CPT"].map(lambda x: x/SEC_IN_100THS_SEC)
    # SMF30CPS : SRB(Service Request Block)時間 (単位：1/100秒）
    df_smf30_fmt["SMF30CPS"] = df_smf30["SMF30CPS"].map(lambda x: x/SEC_IN_100THS_SEC)
        
    df_smf30_fmt.columns = ["SMF_TIME", "SMF_SID", "SMF_SSI", "SMF_STY",
                       'Job_name', 'Pgm_name', 'Step_name', 'Job_number', 'Step_number', 
                      'Time_selected_by_init', 'Date_selected_by_init', 
                        'TCB_time', 'SRB_time']
    
    return df_smf30_fmt
